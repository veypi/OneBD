//
// tpls.go
// Copyright (C) 2024 veypi <i@veypi.com>
// 2024-08-12 18:39
// Distributed under terms of the MIT license.
//

package tpls

import (
	"embed"
	"fmt"
	"os"
	"strings"
	"text/template"
	"time"

	"github.com/veypi/OneBD/clis/cmds"
	"github.com/veypi/utils"
	"github.com/veypi/utils/logx"
)

var (
	tplDir = cmds.Main.String("tpl", "./.tpls", "template dir")
)

type params map[string]any

var Params = func() params {
	m := make(params)
	m["common"] = map[string]any{
		"repo":   *cmds.RepoName,
		"root":   *cmds.DirRoot,
		"api":    *cmds.DirApi,
		"model":  *cmds.DirModel,
		"date":   time.Now().Format("2006-01-02 15:04:05"),
		"noedit": "// Auto generated by OneBD. DO NOT EDIT",
	}
	return m
}

func (p params) WithData(t map[string]any) params {
	for k, v := range t {
		p[k] = v
	}
	return p
}

func (p params) With(k string, v any) params {
	p[k] = v
	return p
}

func OpenFile(p ...string) *os.File {
	fpath := append([]string{*cmds.DirRoot}, p...)
	return OpenAbsFile(fpath...)
}

func OpenAbsFile(p ...string) *os.File {
	fpath := utils.PathJoin(p...)
	if utils.FileExists(fpath) {
		confirmYes(fmt.Sprintf("file %s exists, confirm to overwrite", fpath))
	}
	logx.Info().Msgf("auto generate %s", fpath)
	return logx.AssertFuncErr(utils.MkFile(fpath))
}

func T(p ...string) *template.Template {
	return loadTpl(p...)
}

//go:embed templates
var tplFs embed.FS

func loadTpl(fragment ...string) *template.Template {
	f := utils.PathJoin(fragment...) + ".tpl"
	body, err := tplFs.ReadFile("templates/" + f)
	if err != nil {
		logx.Warn().Msgf("load origin template %s error: %v\n%s\n\n------", f, err, body)
	}
	temp := utils.PathJoin(*tplDir, f)
	if utils.FileExists(temp) {
		logx.Info().Msgf("read template from %s", temp)
		body = logx.AssertFuncErr(os.ReadFile(temp))
	} else if err != nil {
		logx.Warn().Msgf("not found template %s", f)
	}
	tmpl := logx.AssertFuncErr(template.New("").Parse(string(body)))
	return tmpl
}

func confirmYes(txt string) {
	if *cmds.ForceWrite {
		return
	}
	var input string
	fmt.Printf("\033[31m%s, y/n:\033[0m", txt)
	_, err := fmt.Scanln(&input)
	if err != nil {
		os.Exit(0)
	}

	input = strings.ToLower(input)
	if input != "y" {
		os.Exit(0)
	}
}
